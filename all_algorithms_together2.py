# -*- coding: utf-8 -*-
"""All_algorithms_together2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1kPOt_RwEE0iAxFdIj7_HaVPEn_HmzjDw
"""

#We import the necessary libraries
from simpleai.search import SearchProblem, astar, breadth_first, depth_first, greedy, uniform_cost
import numpy as np
import random
import time
import numpy as np
import matplotlib.pyplot as plt
import matplotlib
from matplotlib.colors import LightSource
import plotly.graph_objects as px

mars_map = np.load("map2.npy")
scale = 10.0177
nr, nc = mars_map.shape
max_height = 0.75

def xy_to_rc(x, y):
  r = int(nr - round(y/scale))
  c = int(round(x/scale))
  if 0 <= r < nr and 0 <= c < nc:
      return r,c
  else:
      return None

def get_xy(r,c):
  y = scale*(nr -r)
  x = scale*c
  return y,x

def rc_tuple_to_xy(px):
  r,c = xy_to_rc(px[0],px[1])

  return r,c


def get_height_rc(r,c):
  return mars_map[r][c]

"""# A*"""

initial_state_astar = [
     (3200, 5800)
]

goal_state_astar = [
    (1800, 9700)
]

class AstarMarsRoverMap2(SearchProblem):
  def __init__(self, initial_state, goal_state):
        self.goal_state = goal_state
        super().__init__(initial_state) #Note: The stats will be in rows and columns
  def actions(self,state):
      actual_altitud = get_height_rc(state[0], state[1])
      posible_actions = [(-1, 0), (1, 0), (0, -1), (0, 1), (-1, -1), (-1, 1), (1, -1), (1, 1)]
      actions = []
      for dr, dc in posible_actions:
        if np.abs(actual_altitud - get_height_rc(state[0] + dr, state[1] + dc)) <= max_height:
          actions.append((dr, dc))

      return actions

  def result(self, state, action):
    return (state[0] + action[0], state[1] + action[1])


  def is_goal(self, state):
    return state == goal_state_px

  def cost(self, state, action, state2):
      return np.sqrt((action[0]**2) + (action[1]**2) + (get_height_rc(state[0], state[1]) - get_height_rc(state2[0], state2[1])))


  def heuristic(self,state):
    if state is None:
      return float('inf')
    return ((state[0] - goal_state_px[0])**2+(state[1] - goal_state_px[1])**2)

total_time = []
total_time = []
for i in range(len(initial_state_astar)): #Loop for all 6 locations
    initial_state_px = rc_tuple_to_xy(initial_state_astar[i])
    goal_state_px = rc_tuple_to_xy(goal_state_astar[i])

    print(f"Initial state: {initial_state_px}")
    print(f"Goal state: {goal_state_px}")

    start_time = time.time()
    problem = AstarMarsRoverMap2(initial_state_px, goal_state_px)
    result = astar(problem, graph_search=True)
    time_path = time.time() - start_time
    total_time.append(time_path)
    if result != None:
      print(f"Path found for route {i+1}")
      print(f"The distance explored is: {result.cost} meters")
      print(f"Time for route number is: {i+1}: {time_path} seconds")
      path_px = [step[1] for step in result.path()]

      path_x = []
      path_y = []
      path_z = []

      for r, c in path_px:
          y, x = get_xy(r, c)
          path_x.append(x)
          path_y.append(y)
          path_z.append(mars_map[r, c])


      x = scale * np.arange(mars_map.shape[1])
      y = scale * np.arange(mars_map.shape[0])
      X, Y = np.meshgrid(x, y)

      fig = px.Figure(data=[
          px.Surface(
              x=X, y=Y, z=np.flipud(mars_map), colorscale='hot', cmin=0,
              lighting=dict(ambient=0.0, diffuse=0.8, fresnel=0.02, roughness=0.4, specular=0.2),
              lightposition=dict(x=0, y=mars_map.shape[0] // 2, z=2 * mars_map.max())
          ),
          px.Scatter3d(
              x=path_x, y=path_y, z=path_z, name='Path', mode='markers+lines',
              marker=dict(color=np.linspace(0, 1, len(path_x)), colorscale="Plotly3", size=4)
          )
      ],
          layout=px.Layout(
              scene_aspectmode='manual',
              scene_aspectratio=dict(x=1, y=mars_map.shape[0] / mars_map.shape[1], z=max(mars_map.max() / x.max(), 0.2)),
              scene_zaxis_range=[0, mars_map.max()]
          )
      )

      fig.show()
    else:
        print("No path found")

"""# BFS"""

initial_state_BFS = [
    (5400, 7900), (1800, 3500)
]

goal_state_BFS = [
    (3100, 9100), (2300, 6400)
]

class MarsRoverBFS(SearchProblem):
    def __init__(self, initial_state, goal_state):
        self.goal_state = goal_state
        super().__init__(initial_state) #Note: The stats will be in rows and columns

    def actions(self, state):
        altitude_now = get_height_rc(state[0], state[1])
        posible_movements = [(-1, 0), (1, 0), (0, -1), (0, 1),  (-1, -1), (-1, 1), (1, -1), (1, 1)] #We included diagonal movements too
        actions = []
        for dr, dc in posible_movements:
            if np.abs(altitude_now - get_height_rc(state[0] + dr, state[1] + dc)) <= max_height: #Restriction implementation
                actions.append((dr, dc))
        return actions

    def result(self, state, action):
        return (state[0] + action[0], state[1] + action[1])

    def cost(self, state, action, state2):
        delta_h = np.abs(get_height_rc(state[0], state[1]) - get_height_rc(state2[0], state2[1])) #Change in height
        return np.sqrt(((action[0]*scale)**2)+((action[1]*scale)**2) + (delta_h**2)) #Euclidean distance in 3d in meters


    def is_goal(self, state):
        return state == self.goal_state

total_time = []
for i in range(2): #Loop for all 6 locations
    initial_state_px = rc_tuple_to_xy(initial_state_BFS[i])
    goal_state_px = rc_tuple_to_xy(goal_state_BFS[i])

    print(f"Initial state: {initial_state_px}")
    print(f"Goal state: {goal_state_px}")

    start_time = time.time()
    problem = MarsRoverBFS(initial_state_px, goal_state_px)
    result = breadth_first(problem, graph_search=True)
    time_path = time.time() - start_time
    total_time.append(time_path)
    if result != None:
      print(f"Path found for route {i+1}")
      print(f"The distance explored is: {result.cost} meters")
      print(f"Time for route number is: {i+1}: {time_path} seconds")
      path_px = [step[1] for step in result.path()]

      path_x = []
      path_y = []
      path_z = []

      for r, c in path_px:
          y, x = get_xy(r, c)
          path_x.append(x)
          path_y.append(y)
          path_z.append(mars_map[r, c])


      x = scale * np.arange(mars_map.shape[1])
      y = scale * np.arange(mars_map.shape[0])
      X, Y = np.meshgrid(x, y)

      fig = px.Figure(data=[
          px.Surface(
              x=X, y=Y, z=np.flipud(mars_map), colorscale='hot', cmin=0,
              lighting=dict(ambient=0.0, diffuse=0.8, fresnel=0.02, roughness=0.4, specular=0.2),
              lightposition=dict(x=0, y=mars_map.shape[0] // 2, z=2 * mars_map.max())
          ),
          px.Scatter3d(
              x=path_x, y=path_y, z=path_z, name='Path', mode='markers+lines',
              marker=dict(color=np.linspace(0, 1, len(path_x)), colorscale="Plotly3", size=4)
          )
      ],
          layout=px.Layout(
              scene_aspectmode='manual',
              scene_aspectratio=dict(x=1, y=mars_map.shape[0] / mars_map.shape[1], z=max(mars_map.max() / x.max(), 0.2)),
              scene_zaxis_range=[0, mars_map.max()]
          )
      )

      fig.show()
    else:
        print("No path found")

"""# Greedy Search"""

initial_stateGS = [
    (3900, 3200), (4600, 4800)
]

goal_stateGS = [
    (1000, 7900), (800, 9800)
]

class MarsRoverGreedy(SearchProblem):
    def __init__(self, initial_state, goal_state):
        self.goal_state = goal_state
        super().__init__(initial_state)

    def actions(self, state):
        altitude_now = get_height_rc(state[0], state[1])
        posible_movements = [
            (-1, 0), (1, 0), (0, -1), (0, 1), (-1, -1), (-1, 1), (1, -1), (1, 1)
        ]
        actions = []
        for dr, dc in posible_movements:
            if np.abs(altitude_now - get_height_rc(state[0] + dr, state[1] + dc)) <= max_height:
                actions.append((dr, dc))
        return actions

    def result(self, state, action):
        return (state[0] + action[0], state[1] + action[1])

    def cost(self, state, action, state2):
        delta_h = np.abs(get_height_rc(state[0], state[1]) - get_height_rc(state2[0], state2[1]))
        return np.sqrt(((action[0] * scale) ** 2) + ((action[1] * scale) ** 2) + (delta_h ** 2))

    def is_goal(self, state):
        return state == self.goal_state

    def heuristic(self, state):
        return np.linalg.norm(np.array(state) - np.array(self.goal_state))
total_time = []
for i in range(len(initial_stateGS)): #Loop for all 6 locations
    initial_state_px = rc_tuple_to_xy(initial_stateGS[i])
    goal_state_px = rc_tuple_to_xy(goal_stateGS[i])

    print(f"Initial state: {initial_state_px}")
    print(f"Goal state: {goal_state_px}")

    start_time = time.time()
    problem = MarsRoverGreedy(initial_state_px, goal_state_px)
    result = greedy(problem, graph_search=True)
    time_path = time.time() - start_time
    total_time.append(time_path)
    if result != None:
      print(f"Path found for route {i+1}")
      print(f"The distance explored is: {result.cost} meters")
      print(f"Time for route number is: {i+1}: {time_path} seconds")
      path_px = [step[1] for step in result.path()]

      path_x = []
      path_y = []
      path_z = []

      for r, c in path_px:
          y, x = get_xy(r, c)
          path_x.append(x)
          path_y.append(y)
          path_z.append(mars_map[r, c])


      x = scale * np.arange(mars_map.shape[1])
      y = scale * np.arange(mars_map.shape[0])
      X, Y = np.meshgrid(x, y)

      fig = px.Figure(data=[
          px.Surface(
              x=X, y=Y, z=np.flipud(mars_map), colorscale='hot', cmin=0,
              lighting=dict(ambient=0.0, diffuse=0.8, fresnel=0.02, roughness=0.4, specular=0.2),
              lightposition=dict(x=0, y=mars_map.shape[0] // 2, z=2 * mars_map.max())
          ),
          px.Scatter3d(
              x=path_x, y=path_y, z=path_z, name='Path', mode='markers+lines',
              marker=dict(color=np.linspace(0, 1, len(path_x)), colorscale="Plotly3", size=4)
          )
      ],
          layout=px.Layout(
              scene_aspectmode='manual',
              scene_aspectratio=dict(x=1, y=mars_map.shape[0] / mars_map.shape[1], z=max(mars_map.max() / x.max(), 0.2)),
              scene_zaxis_range=[0, mars_map.max()]
          )
      )

      fig.show()
    else:
        print("No path found")